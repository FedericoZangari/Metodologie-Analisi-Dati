// Class: ReadBDT100
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT100
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.22/08       [398856]
Creator        : federicoz
Date           : Tue Jan  3 11:11:56 2023
Host           : Linux root-ubuntu-2004-2 5.4.0-33-generic #37-Ubuntu SMP Thu May 21 12:53:59 UTC 2020 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/federicoz/MAD/problemi2/train
Training events: 20000
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
NTrees: "100" [Number of trees in the forest]
BoostType: "AdaBoost" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
# Default:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
H: "False" [Print method-specific help message]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
Shrinkage: "1.000000e+00" [Learning rate for BoostType=Grad algorithm]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "2" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "inverseboostnegweights" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
SeparationType: "giniindex" [Separation criterion for node splitting]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 3
x                             x                             x                             x                                                               'F'    [-4.6714553833,4.73376560211]
y                             y                             y                             y                                                               'F'    [-2.6129629612,4.42140054703]
z                             z                             z                             z                                                               'F'    [0.000103908125311,0.99996650219]
NSpec 0


============================================================================ */

#include <array>
#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#include <algorithm>
#include <limits>

#define NN new BDT100Node

#ifndef BDT100Node__def
#define BDT100Node__def

class BDT100Node {

public:

   // constructor of an essentially "empty" node floating in space
   BDT100Node ( BDT100Node* left,BDT100Node* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDT100Node();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDT100Node* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDT100Node* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDT100Node*   fLeft;     // pointer to the left daughter node
   BDT100Node*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 

//_______________________________________________________________________
   BDT100Node::~BDT100Node()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 

//_______________________________________________________________________
bool BDT100Node::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] >= fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}

//_______________________________________________________________________
bool BDT100Node::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}

#endif

#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT100 : public IClassifierReader {

 public:

   // constructor
   ReadBDT100( std::vector<std::string>& theInputVars )
      : IClassifierReader(),
        fClassName( "ReadBDT100" ),
        fNvars( 3 )
   {
      // the training input variables
      const char* inputVars[] = { "x", "y", "z" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT100() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const override;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   double fVmin[3];
   double fVmax[3];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[3];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDT100Node*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT100::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   double norm  = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDT100Node *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDT100Node*)current->GetRight();
         else current=(BDT100Node*)current->GetLeft();
      }
      myMVA += fBoostWeights[itree] *  current->GetNodeType();
      norm  += fBoostWeights[itree];
   }
   return myMVA /= norm;
}

void ReadBDT100::Initialize()
{
  double inf = std::numeric_limits<double>::infinity();
  double nan = std::numeric_limits<double>::quiet_NaN();
  // itree = 0
  fBoostWeights.push_back(0.894481132303497);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.884628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.193634,-99) , 
0, 1.45434, 1, 0, 0.807266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.166667,-99) , 
0, -1.52884, 0, 0, 0.747264,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601732,-99) , 
NN(
0, 
0, 
-1, 1.26316, 1, -1, 0.12677,-99) , 
2, 0.428837, 1, 0, 0.188728,-99) , 
1, 0.736734, 1, 0, 0.5,-99)    );
  // itree = 1
  fBoostWeights.push_back(0.632072);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.89535,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.380516,-99) , 
0, 1.11176, 1, 0, 0.798657,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.155116,-99) , 
0, -1.08151, 0, 0, 0.455265,-99) , 
2, 0.714291, 1, 0, 0.652377,-99) , 
NN(
0, 
0, 
-1, 1.70979, 1, -1, 0.180539,-99) , 
1, 1.0717, 1, 0, 0.496226,-99)    );
  // itree = 2
  fBoostWeights.push_back(0.514046);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.09915, 1, 1, 0.804201,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.617324,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.218642,-99) , 
1, 0.550751, 1, 0, 0.431542,-99) , 
0, 0.860641, 1, 0, 0.690392,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.65655,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452675,-99) , 
0, -0.304498, 0, 0, 0.559472,-99) , 
NN(
0, 
0, 
-1, 1.72581, 1, -1, 0.259553,-99) , 
1, 0.0667946, 1, 0, 0.328019,-99) , 
2, 0.666679, 1, 0, 0.489011,-99)    );
  // itree = 3
  fBoostWeights.push_back(0.404471);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.697366,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442914,-99) , 
2, 0.809516, 1, 0, 0.60482,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.216915,-99) , 
0, 1.59869, 1, 0, 0.561708,-99) , 
NN(
0, 
0, 
-1, 2.25225, 1, -1, 0.10368,-99) , 
1, 1.74164, 1, 0, 0.502514,-99)    );
  // itree = 4
  fBoostWeights.push_back(0.361116);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.720844,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433539,-99) , 
0, -0.832698, 0, 0, 0.626588,-99) , 
NN(
0, 
0, 
-1, 1.85484, 1, -1, 0.395052,-99) , 
0, 0.702957, 1, 0, 0.551975,-99) , 
NN(
0, 
0, 
-1, 2.25225, 1, -1, 0.147729,-99) , 
1, 1.74164, 1, 0, 0.504347,-99)    );
  // itree = 5
  fBoostWeights.push_back(0.217108);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.316063, 1, 1, 0.581013,-99) , 
NN(
0, 
0, 
-1, 2.12464, 1, -1, 0.287214,-99) , 
1, 1.40667, 1, 0, 0.523341,-99)    );
  // itree = 6
  fBoostWeights.push_back(0.222883);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.700535, 1, 1, 0.671045,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.725014,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445564,-99) , 
2, 0.238166, 1, 0, 0.470191,-99) , 
1, -0.156726, 1, 0, 0.51438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.107256,-99) , 
1, 2.07661, 1, 0, 0.490277,-99)    );
  // itree = 7
  fBoostWeights.push_back(0.250145);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.601805,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327942,-99) , 
0, -1.62204, 0, 0, 0.574438,-99) , 
NN(
0, 
0, 
-1, 1.83353, 1, -1, 0.395069,-99) , 
0, 1.15082, 1, 0, 0.538613,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.130539,-99) , 
1, 2.07661, 1, 0, 0.516009,-99)    );
  // itree = 8
  fBoostWeights.push_back(0.141346);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.311274, 1, 1, 0.669262,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.605307,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47092,-99) , 
1, -0.380021, 1, 0, 0.489206,-99) , 
2, 0.285779, 1, 0, 0.511512,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.161643,-99) , 
1, 2.07661, 1, 0, 0.493361,-99)    );
  // itree = 9
  fBoostWeights.push_back(0.132249);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.300467, 1, 1, 0.602814,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515163,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.343427,-99) , 
0, 1.59869, 1, 0, 0.500713,-99) , 
2, 0.571454, 1, 0, 0.53442,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.304542,-99) , 
1, 1.74164, 1, 0, 0.5125,-99)    );
  // itree = 10
  fBoostWeights.push_back(0.123498);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.224494, 0, 1, 0.664198,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450006,-99) , 
0, 0.707807, 1, 0, 0.50968,-99) , 
2, 0.42862, 1, 0, 0.550463,-99) , 
NN(
0, 
0, 
-1, 1.93306, 1, -1, 0.447192,-99) , 
1, 0.401764, 1, 0, 0.489054,-99)    );
  // itree = 11
  fBoostWeights.push_back(0.128033);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.756374,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499,-99) , 
0, -0.0442723, 1, 0, 0.575094,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524205,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411512,-99) , 
0, -0.640646, 0, 0, 0.485871,-99) , 
2, 0.571454, 1, 0, 0.515028,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.361233,-99) , 
1, 1.74164, 1, 0, 0.500805,-99)    );
  // itree = 12
  fBoostWeights.push_back(0.113925);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.547051, 1, 1, 0.714646,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547286,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483946,-99) , 
2, 0.435336, 0, 0, 0.503961,-99) , 
0, 0.142428, 1, 0, 0.578729,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50325,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.409086,-99) , 
0, 0.852782, 1, 0, 0.478438,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.353128,-99) , 
0, -1.53638, 0, 0, 0.464713,-99) , 
2, 0.571454, 1, 0, 0.501403,-99)    );
  // itree = 13
  fBoostWeights.push_back(0.117156);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, -0.253017, 1, 1, 0.586035,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509178,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442762,-99) , 
1, 0.704729, 0, 0, 0.470769,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.351827,-99) , 
1, 1.74164, 1, 0, 0.45926,-99) , 
2, 0.523841, 1, 0, 0.494277,-99)    );
  // itree = 14
  fBoostWeights.push_back(0.104707);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.66142,-99) , 
NN(
NN(
0, 
0, 
-1, 0.421833, 1, 1, 0.528431,-99) , 
NN(
0, 
0, 
-1, 1.93306, 1, -1, 0.446146,-99) , 
1, 0.401764, 1, 0, 0.478325,-99) , 
2, 0.190554, 1, 0, 0.491181,-99)    );
  // itree = 15
  fBoostWeights.push_back(0.0860266);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.637591,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539717,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475637,-99) , 
2, 0.576024, 1, 0, 0.493218,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.392193,-99) , 
1, 1.74164, 1, 0, 0.483949,-99) , 
2, 0.190554, 1, 0, 0.494613,-99)    );
  // itree = 16
  fBoostWeights.push_back(0.0700526);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.638114,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515244,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.378838,-99) , 
0, -1.68592, 0, 0, 0.504847,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.414028,-99) , 
0, 1.59869, 1, 0, 0.495951,-99) , 
2, 0.142941, 1, 0, 0.503166,-99)    );
  // itree = 17
  fBoostWeights.push_back(0.0626374);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.602994,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.578431,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.485511,-99) , 
1, -0.746761, 1, 0, 0.491369,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.399419,-99) , 
1, 1.74164, 1, 0, 0.482972,-99) , 
2, 0.190554, 1, 0, 0.491179,-99)    );
  // itree = 18
  fBoostWeights.push_back(0.0710532);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.181479, 1, 1, 0.523406,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386405,-99) , 
0, 1.71643, 1, 0, 0.512098,-99) , 
NN(
0, 
0, 
-1, -0.351402, 0, -1, 0.424629,-99) , 
2, 0.952354, 1, 0, 0.503027,-99)    );
  // itree = 19
  fBoostWeights.push_back(0.0486558);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.575675,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553227,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489872,-99) , 
1, -0.746761, 1, 0, 0.493833,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401748,-99) , 
1, 1.74164, 1, 0, 0.485464,-99) , 
2, 0.190554, 1, 0, 0.49156,-99)    );
  // itree = 20
  fBoostWeights.push_back(0.0638751);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.707199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495214,-99) , 
2, 0.476431, 1, 0, 0.527958,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503314,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.391845,-99) , 
0, 1.74806, 1, 0, 0.485744,-99) , 
0, 0.255089, 1, 0, 0.507626,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430618,-99) , 
1, 1.74164, 1, 0, 0.50079,-99)    );
  // itree = 21
  fBoostWeights.push_back(0.113399);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.718104,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566544,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47745,-99) , 
0, -0.448731, 0, 0, 0.510331,-99) , 
2, 0.381243, 1, 0, 0.531592,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.571529,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.461891,-99) , 
0, 1.32143, 0, 0, 0.485623,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.386814,-99) , 
0, 1.74799, 1, 0, 0.47053,-99) , 
0, 0.255089, 1, 0, 0.502625,-99)    );
  // itree = 22
  fBoostWeights.push_back(0.0955313);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.694592,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545678,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477193,-99) , 
2, 0.852675, 1, 0, 0.517826,-99) , 
2, 0.381243, 1, 0, 0.535582,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.476933,-99) , 
1, 0.647305, 0, 0, 0.509371,-99) , 
NN(
0, 
0, 
-1, 0.265244, 0, -1, 0.433687,-99) , 
2, 0.428596, 0, 0, 0.488389,-99) , 
0, 0.255089, 1, 0, 0.513192,-99)    );
  // itree = 23
  fBoostWeights.push_back(0.067411);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.428837, 1, 1, 0.537524,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.556763,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484537,-99) , 
2, 0.857022, 0, 0, 0.501268,-99) , 
0, 0.255089, 1, 0, 0.520055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444205,-99) , 
1, 1.74164, 1, 0, 0.513341,-99)    );
  // itree = 24
  fBoostWeights.push_back(0.0466597);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57969,-99) , 
NN(
NN(
0, 
0, 
-1, 1.03795, 0, 1, 0.515052,-99) , 
NN(
0, 
0, 
-1, 1.90383, 1, -1, 0.470803,-99) , 
1, 1.31146, 1, 0, 0.504791,-99) , 
1, -0.603145, 1, 0, 0.510871,-99)    );
  // itree = 25
  fBoostWeights.push_back(0.0271652);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.568281,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55747,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.500126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.438897,-99) , 
1, 1.78991, 1, 0, 0.494667,-99) , 
2, 0.190554, 1, 0, 0.498536,-99) , 
1, -0.603145, 1, 0, 0.504183,-99)    );
  // itree = 26
  fBoostWeights.push_back(0.0345442);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561605,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.550758,-99) , 
NN(
0, 
0, 
-1, 1.78991, 1, -1, 0.489086,-99) , 
2, 0.190554, 1, 0, 0.492879,-99) , 
1, -0.603145, 1, 0, 0.498436,-99)    );
  // itree = 27
  fBoostWeights.push_back(0.0342763);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.553082,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514086,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.491317,-99) , 
0, 0.438856, 1, 0, 0.50432,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466878,-99) , 
2, 0.952354, 1, 0, 0.500453,-99) , 
1, -0.603145, 1, 0, 0.504701,-99)    );
  // itree = 28
  fBoostWeights.push_back(0.0367452);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.560292,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509135,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442419,-99) , 
0, 1.74839, 1, 0, 0.504132,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456851,-99) , 
0, -1.53638, 0, 0, 0.499925,-99) , 
2, 0.190554, 1, 0, 0.503821,-99)    );
  // itree = 29
  fBoostWeights.push_back(0.0375589);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55122,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.56266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475879,-99) , 
2, 0.768724, 1, 0, 0.522165,-99) , 
NN(
0, 
0, 
-1, 1.96497, 1, -1, 0.488509,-99) , 
1, -0.268175, 1, 0, 0.493626,-99) , 
2, 0.190554, 1, 0, 0.497337,-99)    );
  // itree = 30
  fBoostWeights.push_back(0.0286996);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537934,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536362,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495969,-99) , 
0, 1.15082, 0, 0, 0.504142,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46984,-99) , 
1, 1.78991, 1, 0, 0.50114,-99) , 
1, -0.603145, 1, 0, 0.504094,-99)    );
  // itree = 31
  fBoostWeights.push_back(0.0266766);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54326,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522157,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49838,-99) , 
2, 0.807265, 0, 0, 0.508102,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.475878,-99) , 
1, 1.74164, 1, 0, 0.505232,-99) , 
2, 0.190554, 1, 0, 0.507683,-99)    );
  // itree = 32
  fBoostWeights.push_back(0.0408675);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.270906, 1, 1, 0.517345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433782,-99) , 
0, -1.69044, 0, 0, 0.512383,-99) , 
NN(
0, 
0, 
-1, 0.977305, 0, -1, 0.478051,-99) , 
2, 0.952354, 1, 0, 0.508848,-99)    );
  // itree = 33
  fBoostWeights.push_back(0.0543175);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.354215, 1, 1, 0.520818,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.538689,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463117,-99) , 
1, 1.61408, 1, 0, 0.517852,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50175,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434206,-99) , 
1, 0.417699, 1, 0, 0.482939,-99) , 
1, 0.736734, 0, 0, 0.498915,-99) , 
2, 0.333391, 1, 0, 0.501826,-99)    );
  // itree = 34
  fBoostWeights.push_back(0.0628232);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547155,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487767,-99) , 
2, 0.666924, 0, 0, 0.523479,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455798,-99) , 
1, 1.8693, 1, 0, 0.50808,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54953,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483301,-99) , 
2, 0.428616, 1, 0, 0.497345,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423088,-99) , 
1, 0.896061, 1, 0, 0.489156,-99) , 
1, 1.0717, 0, 0, 0.494769,-99)    );
  // itree = 35
  fBoostWeights.push_back(0.0685885);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.700816,-99) , 
NN(
0, 
0, 
-1, 0.682788, 0, -1, 0.484215,-99) , 
2, 0.524026, 1, 0, 0.513164,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586005,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495331,-99) , 
0, 1.41487, 0, 0, 0.509801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.327883,-99) , 
0, 1.91894, 1, 0, 0.494923,-99) , 
0, -0.192779, 1, 0, 0.50198,-99)    );
  // itree = 36
  fBoostWeights.push_back(0.0774168);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.412863, 0, 1, 0.541182,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51697,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474842,-99) , 
1, 0.258191, 1, 0, 0.500301,-99) , 
1, 0.736734, 0, 0, 0.519244,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.615216,-99) , 
NN(
0, 
0, 
-1, 0.265244, 0, -1, 0.441339,-99) , 
0, 0.219093, 1, 0, 0.493326,-99) , 
2, 0.428616, 0, 0, 0.514302,-99)    );
  // itree = 37
  fBoostWeights.push_back(0.0684216);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0412715, 0, 1, 0.521561,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433803,-99) , 
0, 0.492368, 1, 0, 0.490213,-99) , 
2, 0.666679, 0, 0, 0.509695,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.393708,-99) , 
0, 1.83353, 1, 0, 0.495027,-99) , 
0, 1.15082, 1, 0, 0.506798,-99)    );
  // itree = 38
  fBoostWeights.push_back(0.0454333);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.576124,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499942,-99) , 
2, 0.646259, 0, 0, 0.512904,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.441552,-99) , 
0, -1.03202, 0, 0, 0.504577,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517245,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481043,-99) , 
1, 0.736734, 0, 0, 0.498212,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.423444,-99) , 
0, 1.15082, 1, 0, 0.487303,-99) , 
2, 0.714291, 1, 0, 0.495495,-99)    );
  // itree = 39
  fBoostWeights.push_back(0.0465447);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.299796, 1, 1, 0.520408,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.452783,-99) , 
0, -1.03202, 0, 0, 0.51253,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528021,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488523,-99) , 
0, 0.317707, 0, 0, 0.498796,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.434573,-99) , 
0, 1.15082, 1, 0, 0.489446,-99) , 
2, 0.714291, 1, 0, 0.500396,-99)    );
  // itree = 40
  fBoostWeights.push_back(0.0564224);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.224453, 0, 1, 0.553187,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47254,-99) , 
1, -0.0608265, 0, 0, 0.494875,-99) , 
2, 0.428616, 1, 0, 0.507509,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520569,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47809,-99) , 
0, -0.412863, 0, 0, 0.505561,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.403732,-99) , 
2, 0.428837, 0, 0, 0.489631,-99) , 
1, 0.736734, 1, 0, 0.49956,-99)    );
  // itree = 41
  fBoostWeights.push_back(0.0632547);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.664813,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501434,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422434,-99) , 
2, 0.682788, 0, 0, 0.486611,-99) , 
2, 0.524026, 1, 0, 0.50965,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531564,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483088,-99) , 
2, 0.725649, 1, 0, 0.501646,-99) , 
NN(
0, 
0, 
-1, 0.677266, 1, -1, 0.454929,-99) , 
2, 0.476207, 0, 0, 0.487341,-99) , 
0, -0.192779, 1, 0, 0.49599,-99)    );
  // itree = 42
  fBoostWeights.push_back(0.0427672);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.190494, 1, 1, 0.522083,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5214,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471941,-99) , 
1, 0.0445995, 0, 0, 0.50728,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52318,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480087,-99) , 
1, -0.268175, 1, 0, 0.48605,-99) , 
0, 0.702957, 0, 0, 0.492548,-99) , 
2, 0.333391, 1, 0, 0.496394,-99)    );
  // itree = 43
  fBoostWeights.push_back(0.0290362);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522788,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547721,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497263,-99) , 
0, 1.15514, 0, 0, 0.509226,-99) , 
NN(
0, 
0, 
-1, 1.29057, 1, -1, 0.485875,-99) , 
1, 0.593782, 1, 0, 0.496348,-99) , 
1, -0.603145, 1, 0, 0.498446,-99)    );
  // itree = 44
  fBoostWeights.push_back(0.0479489);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.548492,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513268,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477988,-99) , 
2, 0.659959, 0, 0, 0.502424,-99) , 
2, 0.285779, 1, 0, 0.506535,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.408796,-99) , 
0, 1.83353, 1, 0, 0.489201,-99) , 
0, 1.15082, 1, 0, 0.503133,-99)    );
  // itree = 45
  fBoostWeights.push_back(0.0737663);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.608272,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511243,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450948,-99) , 
2, 0.383246, 0, 0, 0.48083,-99) , 
0, -0.216678, 1, 0, 0.509338,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528969,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456488,-99) , 
0, 0.980661, 1, 0, 0.50265,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.446282,-99) , 
2, 0.873002, 1, 0, 0.479584,-99) , 
0, -0.192779, 0, 0, 0.491719,-99) , 
2, 0.619066, 1, 0, 0.497974,-99)    );
  // itree = 46
  fBoostWeights.push_back(0.0360323);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.222226, 0, 1, 0.521802,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516502,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.505628,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47275,-99) , 
2, 0.809547, 0, 0, 0.487524,-99) , 
0, 1.59869, 0, 0, 0.490047,-99) , 
2, 0.333391, 1, 0, 0.494162,-99)    );
  // itree = 47
  fBoostWeights.push_back(0.0569396);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.596276,-99) , 
NN(
0, 
0, 
-1, 0.265356, 0, -1, 0.480662,-99) , 
0, -0.216678, 1, 0, 0.50637,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526676,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478524,-99) , 
2, 0.891136, 0, 0, 0.495241,-99) , 
NN(
0, 
0, 
-1, -1.68568, 0, -1, 0.475124,-99) , 
0, -0.192779, 0, 0, 0.4857,-99) , 
2, 0.619066, 1, 0, 0.493032,-99)    );
  // itree = 48
  fBoostWeights.push_back(0.0495206);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.55247,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516033,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478611,-99) , 
2, 0.612251, 1, 0, 0.505643,-99) , 
0, 1.53029, 0, 0, 0.512572,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.586234,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459415,-99) , 
2, 0.877536, 1, 0, 0.522621,-99) , 
NN(
0, 
0, 
-1, 1.4069, 1, -1, 0.48349,-99) , 
0, -1.08851, 1, 0, 0.491901,-99) , 
2, 0.714291, 1, 0, 0.501669,-99)    );
  // itree = 49
  fBoostWeights.push_back(0.0461048);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.381004, 1, 1, 0.514134,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512036,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.465057,-99) , 
2, 0.666779, 0, 0, 0.493671,-99) , 
1, 0.640978, 1, 0, 0.506486,-99) , 
NN(
NN(
0, 
0, 
-1, 1.68031, 0, 1, 0.529899,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.394766,-99) , 
1, 1.9811, 1, 0, 0.491361,-99) , 
1, 1.40667, 1, 0, 0.503722,-99)    );
  // itree = 50
  fBoostWeights.push_back(0.0475164);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.587551,-99) , 
NN(
0, 
0, 
-1, -1.68568, 0, -1, 0.486293,-99) , 
2, 0.57162, 1, 0, 0.502884,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536536,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488845,-99) , 
2, 0.70529, 1, 0, 0.50328,-99) , 
NN(
0, 
0, 
-1, 0.0311643, 0, -1, 0.470933,-99) , 
2, 0.523817, 0, 0, 0.491898,-99) , 
0, -0.192779, 1, 0, 0.496147,-99)    );
  // itree = 51
  fBoostWeights.push_back(0.048196);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.57599,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5088,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.448267,-99) , 
0, -1.68568, 0, 0, 0.498168,-99) , 
2, 0.57162, 1, 0, 0.510882,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518801,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474796,-99) , 
0, 0.276954, 0, 0, 0.507528,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442705,-99) , 
2, 0.524227, 0, 0, 0.475835,-99) , 
1, 0.0311643, 0, 0, 0.499114,-99) , 
0, -0.192779, 1, 0, 0.503665,-99)    );
  // itree = 52
  fBoostWeights.push_back(0.0324361);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0.222226, 0, 1, 0.514554,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.551824,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493678,-99) , 
2, 0.727952, 1, 0, 0.500097,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.527145,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474062,-99) , 
0, 1.21975, 0, 0, 0.485557,-99) , 
2, 0.682601, 0, 0, 0.495093,-99) , 
2, 0.333391, 1, 0, 0.497598,-99)    );
  // itree = 53
  fBoostWeights.push_back(0.0426267);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561204,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510249,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479027,-99) , 
2, 0.673623, 0, 0, 0.502859,-99) , 
2, 0.428837, 1, 0, 0.509053,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525283,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486289,-99) , 
0, 0.894917, 1, 0, 0.503233,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443793,-99) , 
2, 0.285766, 0, 0, 0.493284,-99) , 
0, 0.255089, 1, 0, 0.501544,-99)    );
  // itree = 54
  fBoostWeights.push_back(0.0291836);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.521753,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499368,-99) , 
2, 0.476229, 1, 0, 0.504806,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472393,-99) , 
1, 1.2152, 1, 0, 0.502329,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.561577,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493978,-99) , 
1, 1.68031, 0, 0, 0.520518,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.406076,-99) , 
1, 1.9811, 1, 0, 0.488099,-99) , 
1, 1.40667, 1, 0, 0.499727,-99)    );
  // itree = 55
  fBoostWeights.push_back(0.0302405);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.192779, 1, 1, 0.508558,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479672,-99) , 
1, 1.2152, 1, 0, 0.506352,-99) , 
NN(
NN(
0, 
0, 
-1, 1.68031, 0, 1, 0.522103,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.413133,-99) , 
1, 1.9811, 1, 0, 0.491277,-99) , 
1, 1.40667, 1, 0, 0.503598,-99)    );
  // itree = 56
  fBoostWeights.push_back(0.0357877);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.536998,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48784,-99) , 
0, -0.448797, 0, 0, 0.496984,-99) , 
2, 0.476431, 1, 0, 0.50233,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5091,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466994,-99) , 
0, 1.74799, 1, 0, 0.502937,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.442164,-99) , 
2, 0.285766, 0, 0, 0.492742,-99) , 
0, 0.255089, 1, 0, 0.497762,-99)    );
  // itree = 57
  fBoostWeights.push_back(0.0345273);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.69398, 0, 1, 0.531585,-99) , 
NN(
0, 
0, 
-1, 0.932106, 0, -1, 0.480383,-99) , 
2, 0.857184, 1, 0, 0.510911,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501866,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.466528,-99) , 
2, 0.285767, 0, 0, 0.496625,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44052,-99) , 
1, 1.73967, 0, 0, 0.470925,-99) , 
1, 1.32337, 1, 0, 0.491156,-99) , 
0, -0.640646, 1, 0, 0.496468,-99)    );
  // itree = 58
  fBoostWeights.push_back(0.0458059);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.69398, 0, 1, 0.522979,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474898,-99) , 
2, 0.932106, 0, 0, 0.489006,-99) , 
2, 0.857184, 1, 0, 0.509258,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.528421,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484288,-99) , 
0, 0.38335, 1, 0, 0.505663,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520736,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474054,-99) , 
0, 1.4647, 0, 0, 0.482447,-99) , 
2, 0.904719, 0, 0, 0.486681,-99) , 
0, -0.640646, 1, 0, 0.492749,-99)    );
  // itree = 59
  fBoostWeights.push_back(0.0414297);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525351,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51478,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47367,-99) , 
2, 0.944915, 1, 0, 0.501638,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53111,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479889,-99) , 
0, 1.44894, 0, 0, 0.487465,-99) , 
2, 0.807265, 0, 0, 0.493279,-99) , 
2, 0.190554, 1, 0, 0.495253,-99)    );
  // itree = 60
  fBoostWeights.push_back(0.0363067);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545411,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502998,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44984,-99) , 
1, 1.3268, 1, 0, 0.495813,-99) , 
1, 1.74164, 0, 0, 0.500685,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516199,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.407042,-99) , 
0, 1.83353, 1, 0, 0.483012,-99) , 
0, 1.15082, 1, 0, 0.497211,-99)    );
  // itree = 61
  fBoostWeights.push_back(0.0435111);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.54261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497422,-99) , 
1, 1.26154, 1, 0, 0.511146,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.463427,-99) , 
1, 1.8693, 1, 0, 0.500303,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.546186,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.48866,-99) , 
1, 0.728564, 0, 0, 0.495419,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.419977,-99) , 
1, 0.896061, 1, 0, 0.487038,-99) , 
1, 1.0717, 0, 0, 0.490992,-99)    );
  // itree = 62
  fBoostWeights.push_back(0.0393719);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547197,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515864,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.488379,-99) , 
0, -0.790386, 1, 0, 0.496421,-99) , 
1, 1.74164, 0, 0, 0.501417,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515481,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.424381,-99) , 
0, 1.83353, 1, 0, 0.487851,-99) , 
0, 1.15082, 1, 0, 0.49875,-99)    );
  // itree = 63
  fBoostWeights.push_back(0.0299777);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.547869,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.537017,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496171,-99) , 
2, 0.965966, 0, 0, 0.499981,-99) , 
2, 0.285779, 1, 0, 0.504132,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514947,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440827,-99) , 
1, 0.550751, 1, 0, 0.483958,-99) , 
0, 1.15082, 1, 0, 0.500169,-99)    );
  // itree = 64
  fBoostWeights.push_back(0.0296435);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542795,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51794,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496592,-99) , 
2, 0.809516, 0, 0, 0.50537,-99) , 
1, 1.74164, 0, 0, 0.509053,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504527,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.432419,-99) , 
0, 1.83353, 1, 0, 0.482713,-99) , 
0, 1.15082, 1, 0, 0.503882,-99)    );
  // itree = 65
  fBoostWeights.push_back(0.0376772);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.543231,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516523,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489461,-99) , 
0, -0.513167, 0, 0, 0.505551,-99) , 
2, 0.333391, 1, 0, 0.509514,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.504667,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445051,-99) , 
1, 0.550751, 1, 0, 0.479772,-99) , 
0, 1.15082, 1, 0, 0.503676,-99)    );
  // itree = 66
  fBoostWeights.push_back(0.0275193);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544328,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519239,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496017,-99) , 
1, 1.07223, 0, 0, 0.503946,-99) , 
1, -0.603145, 1, 0, 0.506934,-99) , 
NN(
0, 
0, 
-1, 1.83353, 1, -1, 0.478199,-99) , 
0, 1.15082, 1, 0, 0.501295,-99)    );
  // itree = 67
  fBoostWeights.push_back(0.0271847);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539379,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.509581,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.489208,-99) , 
1, 1.40667, 1, 0, 0.505521,-99) , 
2, 0.285779, 1, 0, 0.508448,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502593,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444457,-99) , 
0, 1.83353, 1, 0, 0.485069,-99) , 
0, 1.15082, 1, 0, 0.503861,-99)    );
  // itree = 68
  fBoostWeights.push_back(0.0274082);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532618,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514715,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497653,-99) , 
2, 0.591957, 1, 0, 0.501434,-99) , 
2, 0.285779, 1, 0, 0.504128,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.53826,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474448,-99) , 
2, 0.507914, 0, 0, 0.501261,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.443603,-99) , 
2, 0.761889, 1, 0, 0.482361,-99) , 
0, 1.15082, 1, 0, 0.499858,-99)    );
  // itree = 69
  fBoostWeights.push_back(0.0366592);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533563,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518117,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4918,-99) , 
0, -0.235948, 1, 0, 0.504136,-99) , 
1, 1.74164, 0, 0, 0.507023,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531441,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481287,-99) , 
2, 0.507914, 0, 0, 0.502357,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450378,-99) , 
2, 0.761889, 1, 0, 0.485327,-99) , 
0, 1.15082, 1, 0, 0.50277,-99)    );
  // itree = 70
  fBoostWeights.push_back(0.0270755);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.540549, 1, 1, 0.509902,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517689,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.451473,-99) , 
1, 0.63327, 1, 0, 0.487318,-99) , 
0, -1.34482, 0, 0, 0.506644,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.456411,-99) , 
0, 1.83353, 1, 0, 0.489301,-99) , 
0, 1.15082, 1, 0, 0.503246,-99)    );
  // itree = 71
  fBoostWeights.push_back(0.0287005);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.524606,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511509,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490033,-99) , 
0, 0.0412715, 0, 0, 0.498528,-99) , 
2, 0.285779, 1, 0, 0.500771,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520255,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.487884,-99) , 
2, 0.507914, 0, 0, 0.501488,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455965,-99) , 
2, 0.761889, 1, 0, 0.486589,-99) , 
0, 1.15082, 1, 0, 0.497993,-99)    );
  // itree = 72
  fBoostWeights.push_back(0.0457546);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.594003,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495747,-99) , 
2, 0.666854, 1, 0, 0.523238,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510752,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.46285,-99) , 
2, 0.666808, 0, 0, 0.495274,-99) , 
1, 0.401764, 1, 0, 0.505686,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.512961,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47895,-99) , 
2, 0.380986, 0, 0, 0.506016,-99) , 
NN(
0, 
0, 
-1, 0.524227, 0, -1, 0.457154,-99) , 
1, 0.0311643, 0, 0, 0.492073,-99) , 
0, 0.255089, 1, 0, 0.499209,-99)    );
  // itree = 73
  fBoostWeights.push_back(0.0371848);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.666854, 1, 1, 0.528313,-99) , 
NN(
0, 
0, 
-1, 0.57162, 0, -1, 0.49122,-99) , 
1, 0.401764, 1, 0, 0.505027,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526069,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486724,-99) , 
2, 0.523817, 1, 0, 0.49925,-99) , 
NN(
0, 
0, 
-1, 0.524227, 0, -1, 0.468529,-99) , 
1, 0.0311643, 0, 0, 0.490491,-99) , 
0, 0.255089, 1, 0, 0.498111,-99)    );
  // itree = 74
  fBoostWeights.push_back(0.0357654);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.0564064, 1, 1, 0.518645,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477413,-99) , 
2, 0.966017, 0, 0, 0.487835,-99) , 
2, 0.857184, 1, 0, 0.507407,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515476,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.4901,-99) , 
0, 0.894917, 1, 0, 0.501136,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.459972,-99) , 
2, 0.238155, 0, 0, 0.495552,-99) , 
0, 0.255089, 1, 0, 0.501767,-99)    );
  // itree = 75
  fBoostWeights.push_back(0.0326549);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525977,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.50857,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.440062,-99) , 
0, -1.70022, 0, 0, 0.503034,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.471079,-99) , 
0, 1.00106, 1, 0, 0.497955,-99) , 
0, 1.59869, 0, 0, 0.500645,-99)    );
  // itree = 76
  fBoostWeights.push_back(0.0258393);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517829,-99) , 
NN(
NN(
0, 
0, 
-1, 0.354215, 0, 1, 0.511865,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503765,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479848,-99) , 
1, 0.736734, 0, 0, 0.491068,-99) , 
2, 0.333391, 1, 0, 0.493493,-99) , 
0, 1.59869, 0, 0, 0.495829,-99)    );
  // itree = 77
  fBoostWeights.push_back(0.0652712);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.570793,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.577443,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.477316,-99) , 
0, 1.45434, 0, 0, 0.494129,-99) , 
0, -1.52884, 1, 0, 0.501489,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510827,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.44615,-99) , 
2, 0.476421, 0, 0, 0.498621,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.401595,-99) , 
1, 1.96498, 1, 0, 0.486566,-99) , 
1, 0.736734, 1, 0, 0.494845,-99)    );
  // itree = 78
  fBoostWeights.push_back(0.044988);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.549544,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507903,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.481743,-99) , 
2, 0.646301, 0, 0, 0.500913,-99) , 
2, 0.381004, 1, 0, 0.509739,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.523582,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47994,-99) , 
1, 0.91221, 1, 0, 0.488452,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.417377,-99) , 
1, 1.96498, 1, 0, 0.479661,-99) , 
1, 0.736734, 1, 0, 0.496345,-99)    );
  // itree = 79
  fBoostWeights.push_back(0.0397781);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.380964, 1, 1, 0.510298,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457023,-99) , 
1, 0.577208, 1, 0, 0.503415,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.525266,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482028,-99) , 
1, 1.43852, 0, 0, 0.495306,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.428355,-99) , 
1, 1.96498, 1, 0, 0.487045,-99) , 
1, 0.736734, 1, 0, 0.496128,-99)    );
  // itree = 80
  fBoostWeights.push_back(0.0424454);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.557856,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499352,-99) , 
0, -0.299796, 1, 0, 0.508365,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.449495,-99) , 
0, -1.03202, 0, 0, 0.501613,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.552722,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.468074,-99) , 
2, 0.877536, 1, 0, 0.510101,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507607,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.469633,-99) , 
1, 1.13051, 0, 0, 0.48122,-99) , 
0, -1.08851, 1, 0, 0.487396,-99) , 
2, 0.714291, 1, 0, 0.494075,-99)    );
  // itree = 81
  fBoostWeights.push_back(0.0367974);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.43227, 1, 1, 0.515712,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.460019,-99) , 
0, -1.03202, 0, 0, 0.509334,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.542207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478655,-99) , 
2, 0.877536, 1, 0, 0.510194,-99) , 
NN(
0, 
0, 
-1, 1.4069, 1, -1, 0.48534,-99) , 
0, -1.08851, 1, 0, 0.490652,-99) , 
2, 0.714291, 1, 0, 0.499432,-99)    );
  // itree = 82
  fBoostWeights.push_back(0.0288415);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.428616, 1, 1, 0.507002,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511271,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.470185,-99) , 
1, 1.07853, 0, 0, 0.491171,-99) , 
1, 0.832387, 1, 0, 0.502724,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533677,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.499948,-99) , 
0, 0.371802, 0, 0, 0.513207,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.422898,-99) , 
1, 1.9811, 1, 0, 0.487499,-99) , 
1, 1.40667, 1, 0, 0.49994,-99)    );
  // itree = 83
  fBoostWeights.push_back(0.020844);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.52517,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496155,-99) , 
0, -0.838718, 1, 0, 0.500672,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.444716,-99) , 
0, -1.69044, 0, 0, 0.497325,-99) , 
NN(
0, 
0, 
-1, -0.351402, 1, -1, 0.486322,-99) , 
2, 0.952354, 1, 0, 0.496182,-99)    );
  // itree = 84
  fBoostWeights.push_back(0.0319621);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.539998,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503154,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.482999,-99) , 
1, 0.151381, 0, 0, 0.498262,-99) , 
1, -0.560488, 1, 0, 0.501667,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.531338,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.411875,-99) , 
0, -1.77103, 0, 0, 0.491682,-99) , 
0, -1.08851, 0, 0, 0.500026,-99)    );
  // itree = 85
  fBoostWeights.push_back(0.0269821);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522955,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498904,-99) , 
2, 0.381004, 1, 0, 0.503366,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.513762,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480448,-99) , 
0, 0.864715, 0, 0, 0.488561,-99) , 
1, 0.640978, 1, 0, 0.497831,-99) , 
NN(
NN(
0, 
0, 
-1, 0.371802, 0, 1, 0.511332,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.426429,-99) , 
1, 1.9811, 1, 0, 0.48717,-99) , 
1, 1.40667, 1, 0, 0.495882,-99)    );
  // itree = 86
  fBoostWeights.push_back(0.0224367);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.545404,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.495515,-99) , 
2, 0.945571, 1, 0, 0.516488,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.501339,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474299,-99) , 
2, 0.258569, 0, 0, 0.497881,-99) , 
2, 0.904741, 0, 0, 0.501781,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516986,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496565,-99) , 
0, 0.371802, 0, 0, 0.504588,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.433041,-99) , 
1, 1.9811, 1, 0, 0.484252,-99) , 
1, 1.40667, 1, 0, 0.498578,-99)    );
  // itree = 87
  fBoostWeights.push_back(0.0324003);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.533269,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.5161,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.455094,-99) , 
2, 0.954642, 1, 0, 0.488646,-99) , 
1, 0.481214, 1, 0, 0.507697,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.532288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492375,-99) , 
1, 1.72476, 0, 0, 0.496208,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.458052,-99) , 
0, 1.78687, 1, 0, 0.493484,-99) , 
2, 0.904741, 0, 0, 0.496482,-99)    );
  // itree = 88
  fBoostWeights.push_back(0.0291917);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.516694,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498405,-99) , 
0, 0.707807, 1, 0, 0.50973,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.507411,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.480684,-99) , 
1, 1.00569, 1, 0, 0.494671,-99) , 
1, 0.640978, 1, 0, 0.504102,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.520776,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49728,-99) , 
0, 0.0133251, 1, 0, 0.508288,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431918,-99) , 
1, 1.9811, 1, 0, 0.486597,-99) , 
1, 1.40667, 1, 0, 0.500907,-99)    );
  // itree = 89
  fBoostWeights.push_back(0.0448792);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0.921987, 1, 1, 0.520316,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.450951,-99) , 
0, 1.85472, 1, 0, 0.508737,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.510839,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.431278,-99) , 
0, -1.74676, 0, 0, 0.503126,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445622,-99) , 
0, 0.446888, 1, 0, 0.496123,-99) , 
0, 0.702957, 0, 0, 0.50035,-99)    );
  // itree = 90
  fBoostWeights.push_back(0.0379485);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.566662,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.47966,-99) , 
0, 0.440285, 1, 0, 0.509623,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502604,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.479505,-99) , 
0, -0.192779, 0, 0, 0.492055,-99) , 
2, 0.476229, 1, 0, 0.496175,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518098,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.490659,-99) , 
0, 0.371802, 0, 0, 0.50144,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.430635,-99) , 
1, 1.9811, 1, 0, 0.48134,-99) , 
1, 1.40667, 1, 0, 0.493468,-99)    );
  // itree = 91
  fBoostWeights.push_back(0.0254785);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.522944,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497072,-99) , 
1, 0.354215, 0, 0, 0.510003,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515287,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.486234,-99) , 
0, 1.27891, 1, 0, 0.500943,-99) , 
NN(
0, 
0, 
-1, 0.446888, 1, -1, 0.488091,-99) , 
0, 0.702957, 0, 0, 0.492003,-99) , 
2, 0.333391, 1, 0, 0.494272,-99)    );
  // itree = 92
  fBoostWeights.push_back(0.0197265);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514885,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.515489,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514956,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492016,-99) , 
0, 1.44986, 0, 0, 0.495044,-99) , 
1, -0.603145, 1, 0, 0.496605,-99) , 
0, -1.53638, 1, 0, 0.498123,-99)    );
  // itree = 93
  fBoostWeights.push_back(0.0208636);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.519482,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.526235,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.49681,-99) , 
2, 0.498944, 1, 0, 0.502568,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.503798,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.464712,-99) , 
0, 0.067518, 1, 0, 0.484711,-99) , 
1, 1.40667, 1, 0, 0.499222,-99) , 
2, 0.190554, 1, 0, 0.500442,-99)    );
  // itree = 94
  fBoostWeights.push_back(0.0296422);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.517055,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.498676,-99) , 
0, 0.707807, 1, 0, 0.510047,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518754,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.484801,-99) , 
1, 1.11503, 0, 0, 0.49613,-99) , 
1, 0.640978, 1, 0, 0.504842,-99) , 
NN(
NN(
0, 
0, 
-1, 1.65297, 1, 1, 0.510394,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.445952,-99) , 
1, 1.9811, 1, 0, 0.492171,-99) , 
1, 1.40667, 1, 0, 0.502531,-99)    );
  // itree = 95
  fBoostWeights.push_back(0.0188847);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, -0.192779, 1, 1, 0.506381,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.483983,-99) , 
1, 1.2152, 1, 0, 0.504665,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511254,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.493091,-99) , 
1, 1.65297, 1, 0, 0.502985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453288,-99) , 
1, 1.9811, 1, 0, 0.488944,-99) , 
1, 1.40667, 1, 0, 0.501798,-99)    );
  // itree = 96
  fBoostWeights.push_back(0.0224929);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.530985,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496807,-99) , 
2, 0.945571, 1, 0, 0.511159,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.51141,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.492265,-99) , 
2, 0.473956, 1, 0, 0.497882,-99) , 
2, 0.904741, 0, 0, 0.500667,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.511414,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496844,-99) , 
2, 0.809637, 0, 0, 0.502563,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.457972,-99) , 
1, 1.9811, 1, 0, 0.489971,-99) , 
1, 1.40667, 1, 0, 0.498717,-99)    );
  // itree = 97
  fBoostWeights.push_back(0.0253477);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 1.59869, 0, 1, 0.505334,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.474714,-99) , 
1, -0.603145, 0, 0, 0.503017,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.544015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.478917,-99) , 
2, 0.224453, 0, 0, 0.514263,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.453742,-99) , 
1, 0.677266, 1, 0, 0.491125,-99) , 
2, 0.428616, 0, 0, 0.500821,-99)    );
  // itree = 98
  fBoostWeights.push_back(0.015134);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.514361,-99) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.518015,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.497383,-99) , 
0, 1.59869, 0, 0, 0.499374,-99) , 
NN(
0, 
0, 
-1, 0.067518, 1, -1, 0.479721,-99) , 
1, 1.40667, 1, 0, 0.495695,-99) , 
2, 0.190554, 1, 0, 0.496821,-99)    );
  // itree = 99
  fBoostWeights.push_back(0.0227958);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.555633,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.496537,-99) , 
2, 0.619214, 1, 0, 0.507853,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.502893,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.447591,-99) , 
2, 0.19053, 0, 0, 0.497412,-99) , 
0, -0.192779, 1, 0, 0.501402,-99) , 
NN(
NN(
0, 
0, 
-1, 0, 1, 1, 0.508909,-99) , 
NN(
0, 
0, 
-1, 0, 1, -1, 0.472425,-99) , 
2, 0.762082, 1, 0, 0.491458,-99) , 
1, 1.40667, 1, 0, 0.49959,-99)    );
   return;
};

// Clean up
inline void ReadBDT100::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}

inline double ReadBDT100::GetMvaValue( const std::vector<double>& inputValues ) const
{
   // classifier response value
   double retval = 0;

   // classifier response, sanity check first
   if (!IsStatusClean()) {
      std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                << " because status is dirty" << std::endl;
   }
   else {
         retval = GetMvaValue__( inputValues );
   }

   return retval;
}
